// Autogenerated from Pigeon (v10.0.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import

import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

/// A class representing an Address.
///
/// The address format is a simplified version of xAL (eXtensible Address Language, http://www.oasis-open.org/committees/ciq/ciq.html#6).
class Address {
  Address({
    required this.addressLines,
    this.adminArea,
    this.countryCode,
    this.countryName,
    this.featureName,
    required this.latitude,
    required this.locale,
    this.locality,
    required this.longitude,
    this.phone,
    this.postalCode,
    this.premises,
    this.subAdminArea,
    this.subLocality,
    this.subThoroughfare,
    this.thoroughfare,
    this.url,
  });

  /// The address lines associated with the address.
  List<String?> addressLines;

  /// The administrative area associated with the address.
  String? adminArea;

  /// The abbreviated country name, according to the two letter (alpha-2) [ISO standard](https://www.iso.org/iso-3166-country-codes.html).
  String? countryCode;

  /// The name of the country associated with the address.
  String? countryName;

  /// The feature name associated with the address.
  String? featureName;

  /// The latitude associated with the address.
  double latitude;

  /// The locale associated with the address.
  String locale;

  /// The name of the city associated with the address.
  String? locality;

  /// The longitude associated with the address.
  double longitude;

  /// The phone number associated with the address.
  String? phone;

  /// The postal code associated with the address.
  String? postalCode;

  /// The premises associated with the address.
  String? premises;

  /// Additional administrative area information for the placemark.
  String? subAdminArea;

  /// Additional city-level information for the address.
  String? subLocality;

  /// Additional street address information for the address.
  String? subThoroughfare;

  /// The street address associated with the address.
  String? thoroughfare;

  /// The url associated with the address.
  String? url;

  Object encode() {
    return <Object?>[
      addressLines,
      adminArea,
      countryCode,
      countryName,
      featureName,
      latitude,
      locale,
      locality,
      longitude,
      phone,
      postalCode,
      premises,
      subAdminArea,
      subLocality,
      subThoroughfare,
      thoroughfare,
      url,
    ];
  }

  static Address decode(Object result) {
    result as List<Object?>;
    return Address(
      addressLines: (result[0] as List<Object?>?)!.cast<String?>(),
      adminArea: result[1] as String?,
      countryCode: result[2] as String?,
      countryName: result[3] as String?,
      featureName: result[4] as String?,
      latitude: result[5]! as double,
      locale: result[6]! as String,
      locality: result[7] as String?,
      longitude: result[8]! as double,
      phone: result[9] as String?,
      postalCode: result[10] as String?,
      premises: result[11] as String?,
      subAdminArea: result[12] as String?,
      subLocality: result[13] as String?,
      subThoroughfare: result[14] as String?,
      thoroughfare: result[15] as String?,
      url: result[16] as String?,
    );
  }
}

/// A class representing a specific geographical, political or cultural region.
class Locale {
  Locale({
    required this.language,
    this.country,
    this.variant,
  });

  /// The [language] of the current [Locale].
  ///
  /// The [language] is formatted according to the ISO 639 alpha-2 or alpha-3
  /// language code standard, or a language subtag up to 8 characters in
  /// length. See the [Android Locale class](https://developer.android.com/reference/java/util/Locale)
  /// description about valid language values.
  String language;

  /// The [country] of the current [Locale].
  ///
  /// The [country] is formatted according to the ISO 3166 alpha-2 country code
  /// or a UN M.49 numeric-3 area code. See the [Android Locale class](https://developer.android.com/reference/java/util/Locale)
  /// description about valid language values.
  String? country;

  /// The [variant] of the current [Locale].
  ///
  /// The [variant] can be any arbitrary value used to indicate a variation of
  /// a Locale. See the [Android Locale class](https://developer.android.com/reference/java/util/Locale) description about valid language values.
  String? variant;

  Object encode() {
    return <Object?>[
      language,
      country,
      variant,
    ];
  }

  static Locale decode(Object result) {
    result as List<Object?>;
    return Locale(
      language: result[0]! as String,
      country: result[1] as String?,
      variant: result[2] as String?,
    );
  }
}

/// Host API for managing the native `InstanceManager`.
class InstanceManagerHostApi {
  /// Constructor for [InstanceManagerHostApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  InstanceManagerHostApi({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = StandardMessageCodec();

  /// Clear the native `InstanceManager`.
  ///
  /// This is typically only used after a hot restart.
  Future<void> clear() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.InstanceManagerHostApi.clear', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }
}

/// Handles methods calls to the native Java Object class.
///
/// Also handles calls to remove the reference to an instance with `dispose`.
///
/// See https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html.
class JavaObjectHostApi {
  /// Constructor for [JavaObjectHostApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  JavaObjectHostApi({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = StandardMessageCodec();

  Future<void> dispose(String arg_identifier) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.JavaObjectHostApi.dispose', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_identifier]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }
}

/// Handles callbacks methods for the native Java Object class.
///
/// See https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html.
abstract class JavaObjectFlutterApi {
  static const MessageCodec<Object?> codec = StandardMessageCodec();

  void dispose(String identifier);

  static void setup(JavaObjectFlutterApi? api, {BinaryMessenger? binaryMessenger}) {
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.JavaObjectFlutterApi.dispose', codec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.JavaObjectFlutterApi.dispose was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_identifier = (args[0] as String?);
          assert(arg_identifier != null,
              'Argument for dev.flutter.pigeon.JavaObjectFlutterApi.dispose was null, expected non-null String.');
          api.dispose(arg_identifier!);
          return;
        });
      }
    }
  }
}

class _GeocoderHostApiCodec extends StandardMessageCodec {
  const _GeocoderHostApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is Locale) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return Locale.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

/// Host API for `Geocoding`.
///
/// This class may handle instantiating and adding native object instances that
/// are attached to a Dart instance or handle method calls on the associated
/// native class or an instance of the class.
class GeocoderHostApi {
  /// Constructor for [GeocoderHostApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  GeocoderHostApi({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _GeocoderHostApiCodec();

  /// Creates a new native instance and adds it to the `InstanceManager`.
  Future<void> create(String arg_instanceId, Locale arg_locale) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.GeocoderHostApi.create', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_instanceId, arg_locale]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  /// Request a list of [Address]es that attempt to describe the surroundings
  /// of the provided [latitude] and [longitude].
  ///
  /// The [maxResults] indicates the max number of [Address]es to be returned.
  /// Smaller numbers (1 to 5) are recommended.
  ///
  /// The [geocodeListenerInstanceId] refers to the [GeocodeListenerFlutterApi]
  /// instance that should be used to receive the results.
  Future<void> getFromLocation(String arg_instanceId, double arg_latitude, double arg_longitude, int arg_maxResults, String arg_geocodeListenerInstanceId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.GeocoderHostApi.getFromLocation', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_instanceId, arg_latitude, arg_longitude, arg_maxResults, arg_geocodeListenerInstanceId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  /// Requests an array of [Address]es that attempt to describe the named
  /// [address].
  ///
  /// The [address] may be a place name such as "Dalvik, Iceland", an address
  /// such as "1600 Amphitheatre Parkway, Mountain View, CA", an airport code
  /// such as "SFO", and so forth. The resulting addresses should be localized
  /// for the locale provided to this class's constructor.
  ///
  /// The [geocodeListenerInstanceId] refers to the [GeocodeListenerFlutterApi]
  /// instance that should be used to receive the results.
  ///
  /// You may specify a bounding box for the search results by including the
  /// latitude and longitude of the lower left point and upper right point of
  /// the box.
  Future<void> getFromLocationName(String arg_instanceId, String arg_address, String arg_geocodeListenerInstanceId, int? arg_maxResults, double? arg_lowerLeftLatitude, double? arg_lowerLeftLongitude, double? arg_upperRightLatitude, double? arg_upperRightLongitude) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.GeocoderHostApi.getFromLocationName', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_instanceId, arg_address, arg_geocodeListenerInstanceId, arg_maxResults, arg_lowerLeftLatitude, arg_lowerLeftLongitude, arg_upperRightLatitude, arg_upperRightLongitude]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  /// Indicates if a geocoder implementation is present that may return results.
  ///
  /// If `true`, there is still no guarantee that any individual geocoding
  /// attempt will succeed.
  Future<bool> isPresent() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.GeocoderHostApi.isPresent', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as bool?)!;
    }
  }
}

class GeocodeListenerHostApi {
  /// Constructor for [GeocodeListenerHostApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  GeocodeListenerHostApi({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = StandardMessageCodec();

  Future<void> create(String arg_instanceId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.GeocodeListenerHostApi.create', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_instanceId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }
}

class _GeocodeListenerFlutterApiCodec extends StandardMessageCodec {
  const _GeocodeListenerFlutterApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is Address) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return Address.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

abstract class GeocodeListenerFlutterApi {
  static const MessageCodec<Object?> codec = _GeocodeListenerFlutterApiCodec();

  void onError(String instanceId, String errorMessage);

  void onGeocode(String instanceId, List<Address?> addresses);

  static void setup(GeocodeListenerFlutterApi? api, {BinaryMessenger? binaryMessenger}) {
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.GeocodeListenerFlutterApi.onError', codec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.GeocodeListenerFlutterApi.onError was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_instanceId = (args[0] as String?);
          assert(arg_instanceId != null,
              'Argument for dev.flutter.pigeon.GeocodeListenerFlutterApi.onError was null, expected non-null String.');
          final String? arg_errorMessage = (args[1] as String?);
          assert(arg_errorMessage != null,
              'Argument for dev.flutter.pigeon.GeocodeListenerFlutterApi.onError was null, expected non-null String.');
          api.onError(arg_instanceId!, arg_errorMessage!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.GeocodeListenerFlutterApi.onGeocode', codec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.GeocodeListenerFlutterApi.onGeocode was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final String? arg_instanceId = (args[0] as String?);
          assert(arg_instanceId != null,
              'Argument for dev.flutter.pigeon.GeocodeListenerFlutterApi.onGeocode was null, expected non-null String.');
          final List<Address?>? arg_addresses = (args[1] as List<Object?>?)?.cast<Address?>();
          assert(arg_addresses != null,
              'Argument for dev.flutter.pigeon.GeocodeListenerFlutterApi.onGeocode was null, expected non-null List<Address?>.');
          api.onGeocode(arg_instanceId!, arg_addresses!);
          return;
        });
      }
    }
  }
}
